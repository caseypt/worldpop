[
  {
    "description": "Options object for the `worldpop` function.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "WorldpopOpts"
      },
      {
        "title": "typedef",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "WorldpopOpts"
      },
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "minzoom"
      },
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "maxzoom"
      },
      {
        "title": "property",
        "description": "A GeoJSON Feature\nstream or Tilelive uri for the tiled population data, where each feature\nrepresents an area of constant population density.",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "ReadableStream"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Feature"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "property",
        "description": "If `source` is a tile source, the layer in which\nto find the population features.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "layer"
      },
      {
        "title": "property",
        "description": "A function that accepts a feature from\n`source` and returns the population density for that feature.",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "density"
      },
      {
        "title": "property",
        "description": "The polygon whose interior population\nwe want.",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Feature"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Polygon"
            }
          ]
        },
        "name": "polygon"
      },
      {
        "title": "property",
        "description": "A progress callback, called periodically\nwith the current state of {totalPopulation, totalArea, polygonArea}. (You\ncan estimate % complete with totalArea/polygonArea.)",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "progress"
      },
      {
        "title": "property",
        "description": "Frequency (in # of features) of\nprogress callback.",
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "progressFrequency"
      },
      {
        "title": "kind",
        "kind": "typedef"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 48,
          "column": 0
        },
        "end": {
          "line": 86,
          "column": 1
        }
      },
      "file": "/Users/anand/ds/worldpop/index.js",
      "code": "'use strict'\n\nvar xtend = require('xtend')\nvar turfarea = require('turf-area')\nvar through = require('through2')\nvar tiledData = require('./lib/tiled-data')\nvar clip = require('./lib/clip')\nvar fix = require('./lib/fix')\nvar debug = require('debug')('polypop:main')\nvar debugTotal = require('debug')('polypop:totalTime')\n\nvar DEFAULT_PROGRESS_FREQ = 100\n\n/**\n * Computes the total population within the given polygon.\n *\n * @name worldpop\n * @param {WorldpopOpts} opts - Options.\n * @param cb - completion callback, called with {totalPopulation, totalArea,\n * polygonArea}.\n * @returns {ReadableStream<Feature>} - a GeoJSON feature stream of\n * constant-population polygons, clipped to the poly of interest\n */\nmodule.exports = worldpop\n\n/**\n * Options object for the `worldpop` function.\n * @name WorldpopOpts\n * @typedef {Object} WorldpopOpts\n * @property {number} minzoom\n * @property {number} maxzoom\n * @property {(string|ReadableStream<Feature>)} source - A GeoJSON Feature\n * stream or Tilelive uri for the tiled population data, where each feature\n * represents an area of constant population density.\n * @property {string} layer - If `source` is a tile source, the layer in which\n * to find the population features.\n * @property {function} density - A function that accepts a feature from\n * `source` and returns the population density for that feature.\n * @property {Feature<Polygon>} polygon - The polygon whose interior population\n * we want.\n * @property {function} progress - A progress callback, called periodically\n * with the current state of {totalPopulation, totalArea, polygonArea}. (You\n * can estimate % complete with totalArea/polygonArea.)\n * @property {Number} progressFrequency - Frequency (in # of features) of\n * progress callback.\n */\n\nfunction worldpop (opts, cb) {\n  opts.min_zoom = opts.min_zoom || 8\n  opts.max_zoom = opts.max_zoom || 12\n\n  var poly = opts.polygon\n  var source = typeof opts.source.pipe === 'function' ? opts.source :\n    tiledData(opts.source, opts.layer, poly, opts)\n  var progressFrequency = opts.progressFrequency || DEFAULT_PROGRESS_FREQ\n\n  var result = {\n    count: 0,\n    totalPopulation: 0,\n    totalArea: 0,\n    polygonArea: turfarea(poly)\n  }\n\n  debugTotal('start', Date.now())\n  return source\n    .pipe(fix())\n    .pipe(clip(poly))\n    .pipe(through.obj(function write (feat, _, next) {\n      next(null, popped(opts.density, poly, feat))\n    }))\n    .on('data', function (feat) {\n      result.totalPopulation += feat.properties.population\n      result.totalArea += feat.properties.area\n      result.count++\n      if (opts.progress && result.count % progressFrequency === 0) {\n        var snap = xtend({}, result)\n        setTimeout(function () { opts.progress(snap) }, 0)\n      }\n    })\n    .on('end', function () {\n      debugTotal('end', Date.now())\n      debugTotal(result)\n      cb(null, result)\n    })\n    .on('error', cb)\n}\n\nfunction popped (densityFn, poly, feat) {\n  var density = densityFn(feat)\n  feat.properties.area = turfarea(feat)\n  feat.properties.population = feat.properties.area * density\n  debug(feat.properties)\n  return feat\n}"
    },
    "name": "WorldpopOpts",
    "properties": [
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "minzoom"
      },
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "maxzoom"
      },
      {
        "title": "property",
        "description": "A GeoJSON Feature\nstream or Tilelive uri for the tiled population data, where each feature\nrepresents an area of constant population density.",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "ReadableStream"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Feature"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "property",
        "description": "If `source` is a tile source, the layer in which\nto find the population features.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "layer"
      },
      {
        "title": "property",
        "description": "A function that accepts a feature from\n`source` and returns the population density for that feature.",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "density"
      },
      {
        "title": "property",
        "description": "The polygon whose interior population\nwe want.",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Feature"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Polygon"
            }
          ]
        },
        "name": "polygon"
      },
      {
        "title": "property",
        "description": "A progress callback, called periodically\nwith the current state of {totalPopulation, totalArea, polygonArea}. (You\ncan estimate % complete with totalArea/polygonArea.)",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "progress"
      },
      {
        "title": "property",
        "description": "Frequency (in # of features) of\nprogress callback.",
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "progressFrequency"
      }
    ],
    "kind": "typedef",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "WorldpopOpts"
    ]
  },
  {
    "description": "Computes the total population within the given polygon.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "worldpop"
      },
      {
        "title": "param",
        "description": "Options.",
        "type": {
          "type": "NameExpression",
          "name": "WorldpopOpts"
        },
        "name": "opts"
      },
      {
        "title": "param",
        "description": "completion callback, called with {totalPopulation, totalArea,\npolygonArea}.",
        "type": null,
        "name": "cb"
      },
      {
        "title": "returns",
        "description": "a GeoJSON feature stream of\nconstant-population polygons, clipped to the poly of interest",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "ReadableStream"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Feature"
            }
          ]
        }
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 24,
          "column": 0
        },
        "end": {
          "line": 48,
          "column": 0
        }
      },
      "file": "/Users/anand/ds/worldpop/index.js",
      "code": "'use strict'\n\nvar xtend = require('xtend')\nvar turfarea = require('turf-area')\nvar through = require('through2')\nvar tiledData = require('./lib/tiled-data')\nvar clip = require('./lib/clip')\nvar fix = require('./lib/fix')\nvar debug = require('debug')('polypop:main')\nvar debugTotal = require('debug')('polypop:totalTime')\n\nvar DEFAULT_PROGRESS_FREQ = 100\n\n/**\n * Computes the total population within the given polygon.\n *\n * @name worldpop\n * @param {WorldpopOpts} opts - Options.\n * @param cb - completion callback, called with {totalPopulation, totalArea,\n * polygonArea}.\n * @returns {ReadableStream<Feature>} - a GeoJSON feature stream of\n * constant-population polygons, clipped to the poly of interest\n */\nmodule.exports = worldpop\n\n/**\n * Options object for the `worldpop` function.\n * @name WorldpopOpts\n * @typedef {Object} WorldpopOpts\n * @property {number} minzoom\n * @property {number} maxzoom\n * @property {(string|ReadableStream<Feature>)} source - A GeoJSON Feature\n * stream or Tilelive uri for the tiled population data, where each feature\n * represents an area of constant population density.\n * @property {string} layer - If `source` is a tile source, the layer in which\n * to find the population features.\n * @property {function} density - A function that accepts a feature from\n * `source` and returns the population density for that feature.\n * @property {Feature<Polygon>} polygon - The polygon whose interior population\n * we want.\n * @property {function} progress - A progress callback, called periodically\n * with the current state of {totalPopulation, totalArea, polygonArea}. (You\n * can estimate % complete with totalArea/polygonArea.)\n * @property {Number} progressFrequency - Frequency (in # of features) of\n * progress callback.\n */\n\nfunction worldpop (opts, cb) {\n  opts.min_zoom = opts.min_zoom || 8\n  opts.max_zoom = opts.max_zoom || 12\n\n  var poly = opts.polygon\n  var source = typeof opts.source.pipe === 'function' ? opts.source :\n    tiledData(opts.source, opts.layer, poly, opts)\n  var progressFrequency = opts.progressFrequency || DEFAULT_PROGRESS_FREQ\n\n  var result = {\n    count: 0,\n    totalPopulation: 0,\n    totalArea: 0,\n    polygonArea: turfarea(poly)\n  }\n\n  debugTotal('start', Date.now())\n  return source\n    .pipe(fix())\n    .pipe(clip(poly))\n    .pipe(through.obj(function write (feat, _, next) {\n      next(null, popped(opts.density, poly, feat))\n    }))\n    .on('data', function (feat) {\n      result.totalPopulation += feat.properties.population\n      result.totalArea += feat.properties.area\n      result.count++\n      if (opts.progress && result.count % progressFrequency === 0) {\n        var snap = xtend({}, result)\n        setTimeout(function () { opts.progress(snap) }, 0)\n      }\n    })\n    .on('end', function () {\n      debugTotal('end', Date.now())\n      debugTotal(result)\n      cb(null, result)\n    })\n    .on('error', cb)\n}\n\nfunction popped (densityFn, poly, feat) {\n  var density = densityFn(feat)\n  feat.properties.area = turfarea(feat)\n  feat.properties.population = feat.properties.area * density\n  debug(feat.properties)\n  return feat\n}"
    },
    "name": "worldpop",
    "params": [
      {
        "title": "param",
        "description": "Options.",
        "type": {
          "type": "NameExpression",
          "name": "WorldpopOpts"
        },
        "name": "opts"
      },
      {
        "title": "param",
        "description": "completion callback, called with {totalPopulation, totalArea,\npolygonArea}.",
        "type": null,
        "name": "cb"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a GeoJSON feature stream of\nconstant-population polygons, clipped to the poly of interest",
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "ReadableStream"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Feature"
            }
          ]
        }
      }
    ],
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "worldpop"
    ]
  }
]
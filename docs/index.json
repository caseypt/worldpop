[
  {
    "description": "Computes the total population within the given polygon.",
    "tags": [
      {
        "title": "param",
        "description": "Options:\nmax_zoom, min_zoom\n\n{(string|ReadableStream<Feature>)} source - A GeoJSON Feature\nstream or Tilelive uri for the tiled population data, where each feature\nrepresents an area of constant population density.\n\n{function} density - A function that accepts a feature from\n`source` and returns the population density for that feature.\n\n{Feature<Polygon>} polygon - The polygon whose interior\npopulation we want.\n\n{function} progress - A progress callback, called periodically\nwith the current state of {totalPopulation, totalArea, polygonArea}. (You can\nestimate % complete with totalArea/polygonArea.)\n\n{Number} progressFrequency - Frequency (in # of features) of\nprogress callback.",
        "type": null,
        "name": "opts"
      },
      {
        "title": "param",
        "description": "completion callback, called with {totalPopulation, totalArea,\npolygonArea}.",
        "type": null,
        "name": "cb"
      },
      {
        "title": "name",
        "name": "worldpop"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 43,
          "column": 0
        },
        "end": {
          "line": 81,
          "column": 1
        }
      },
      "file": "/Users/anand/ds/worldpop/index.js",
      "code": "'use strict'\n\nvar xtend = require('xtend')\nvar turfarea = require('turf-area')\nvar through = require('through2')\nvar tiledData = require('./lib/tiled-data')\nvar clip = require('./lib/clip')\nvar fix = require('./lib/fix')\nvar debug = require('debug')('polypop:main')\nvar debugTotal = require('debug')('polypop:totalTime')\n\nvar DEFAULT_PROGRESS_FREQ = 100\n\nmodule.exports = worldpop\n\n/**\n * Computes the total population within the given polygon.\n *\n * @param opts - Options:\n * max_zoom, min_zoom\n *\n * {(string|ReadableStream<Feature>)} source - A GeoJSON Feature\n * stream or Tilelive uri for the tiled population data, where each feature\n * represents an area of constant population density.\n *\n * {function} density - A function that accepts a feature from\n * `source` and returns the population density for that feature.\n *\n * {Feature<Polygon>} polygon - The polygon whose interior\n * population we want.\n *\n * {function} progress - A progress callback, called periodically\n * with the current state of {totalPopulation, totalArea, polygonArea}. (You can\n * estimate % complete with totalArea/polygonArea.)\n *\n * {Number} progressFrequency - Frequency (in # of features) of\n * progress callback.\n * @param cb - completion callback, called with {totalPopulation, totalArea,\n * polygonArea}.\n * @return - a GeoJSON feature stream of constant-population polygons, clipped\n * to the poly of interest\n */\nfunction worldpop (opts, cb) {\n  opts.min_zoom = opts.min_zoom || 8\n  opts.max_zoom = opts.max_zoom || 12\n\n  var poly = opts.polygon\n  var source = typeof opts.source.pipe === 'function' ? opts.source :\n    tiledData(opts.source, poly, opts)\n  var progressFrequency = opts.progressFrequency || DEFAULT_PROGRESS_FREQ\n\n  var result = {\n    count: 0,\n    totalPopulation: 0,\n    totalArea: 0,\n    polygonArea: turfarea(poly)\n  }\n\n  debugTotal('start', Date.now())\n  return source\n    .pipe(fix())\n    .pipe(clip(poly))\n    .pipe(through.obj(function write (feat, _, next) {\n      next(null, popped(opts.density, poly, feat))\n    }))\n    .on('data', function (feat) {\n      result.totalPopulation += feat.properties.population\n      result.totalArea += feat.properties.area\n      result.count++\n      if (opts.progress && result.count % progressFrequency === 0) {\n        var snap = xtend({}, result)\n        setTimeout(function () { opts.progress(snap) }, 0)\n      }\n    })\n    .on('end', function () {\n      debugTotal('end', Date.now())\n      debugTotal(result)\n      cb(null, result)\n    })\n    .on('error', cb)\n}\n\nfunction popped (densityFn, poly, feat) {\n  var density = densityFn(feat)\n  feat.properties.area = turfarea(feat)\n  feat.properties.population = feat.properties.area * density\n  debug(feat.properties)\n  return feat\n}"
    },
    "params": [
      {
        "title": "param",
        "description": "Options:\nmax_zoom, min_zoom\n\n{(string|ReadableStream<Feature>)} source - A GeoJSON Feature\nstream or Tilelive uri for the tiled population data, where each feature\nrepresents an area of constant population density.\n\n{function} density - A function that accepts a feature from\n`source` and returns the population density for that feature.\n\n{Feature<Polygon>} polygon - The polygon whose interior\npopulation we want.\n\n{function} progress - A progress callback, called periodically\nwith the current state of {totalPopulation, totalArea, polygonArea}. (You can\nestimate % complete with totalArea/polygonArea.)\n\n{Number} progressFrequency - Frequency (in # of features) of\nprogress callback.",
        "type": null,
        "name": "opts"
      },
      {
        "title": "param",
        "description": "completion callback, called with {totalPopulation, totalArea,\npolygonArea}.",
        "type": null,
        "name": "cb"
      }
    ],
    "name": "worldpop",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "worldpop"
    ]
  }
]